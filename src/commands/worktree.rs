//! Worktree operations with dual-mode output for shell integration.
//!
//! # The Directory Change Problem
//!
//! Worktree commands (`switch`, `remove`, `merge`) need to change the user's working directory,
//! but there's a fundamental Unix limitation: **child processes cannot change their parent's
//! working directory**. This is a security feature and core Unix design principle.
//!
//! When a user runs `wt switch my-feature`, the `wt` binary runs as a child process of the shell.
//! The binary can change *its own* working directory, but when it exits, the parent shell remains
//! in the original directory.
//!
//! # Solution: Dual-Mode Output
//!
//! We solve this with two output modes:
//!
//! ## Without `--internal` (Direct Binary Call)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! To enable automatic cd, run: wt configure-shell
//!
//! $ pwd
//! /original/directory  # ‚Üê User is still here!
//! ```
//!
//! The binary performs git operations and prints user-friendly messages, but **cannot** change
//! the parent shell's directory. User must manually `cd` to the worktree.
//!
//! ## With `--internal` (Via Shell Wrapper)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! $ pwd
//! /path/to/worktree  # ‚Üê Automatically changed!
//! ```
//!
//! When shell integration is enabled (`eval "$(wt init bash)"`), the shell function intercepts
//! commands and adds `--internal`:
//!
//! 1. Shell wrapper calls: `wt switch --internal my-feature`
//! 2. Binary outputs special directive protocol:
//!    ```
//!    __WORKTRUNK_CD__/path/to/worktree
//!    Created new branch and worktree for 'my-feature' at /path/to/worktree
//!    ```
//! 3. Shell wrapper parses output line-by-line
//! 4. When it sees `__WORKTRUNK_CD__<path>`, it executes `cd <path>` in the parent shell
//! 5. Other lines are printed normally
//!
//! The binary **never changes directories itself** - it just communicates the desired path back
//! to the shell wrapper via stdout using the `__WORKTRUNK_CD__` directive protocol.
//!
//! # Implementation Details
//!
//! Result types (`SwitchResult`, `RemoveResult`) are pure data structures that only contain
//! operation results. All presentation logic is handled by the `output` module:
//!
//! - `output::handle_switch_output()`: Formats and outputs switch operation results
//! - `output::handle_remove_output()`: Formats and outputs remove operation results
//!
//! These handlers automatically select the appropriate mode (user-friendly or directive protocol)
//! based on the `internal` flag
//!
//! ## Directive Protocol
//!
//! Directives are NUL-terminated to support multi-line commands (e.g., via `-x` flag):
//!
//! ```text
//! __WORKTRUNK_CD__/path/to/worktree\0
//! Message for user\0
//! __WORKTRUNK_EXEC__echo 'line1'\necho 'line2'\0
//! ```
//!
//! Shell wrappers split on `\0` bytes and process each chunk:
//! - `__WORKTRUNK_CD__<path>`: Change directory to `<path>`
//! - `__WORKTRUNK_EXEC__<command>`: Execute `<command>` (may contain newlines)
//! - Other chunks: Print as regular output
//!
//! ## Exit Code Semantics
//!
//! When using `-x` to execute commands after switching:
//!
//! - **Exit code returned**: The `wt` command's exit code
//! - **Command execution**: Runs for side effects; failures are logged but don't affect exit code
//! - **Rationale**: Allows scripts to detect `wt` failures (e.g., branch already exists) while
//!   still executing post-switch commands for convenience
//!
//! Example:
//! ```bash
//! wt switch --create feature -x "editor ."  # Opens editor even if branch exists
//! echo $?  # Returns wt's exit code, not editor's
//! ```
//!
//! The shell wrapper is generated by `wt init <shell>` from templates in `templates/`.
//!
//! See also: DEMO.md for detailed architecture explanation.

use std::collections::HashMap;
use std::io::{self, Write};
use std::path::PathBuf;
use worktrunk::config::{ProjectConfig, WorktrunkConfig, expand_template};
use worktrunk::git::{GitError, Repository};
use worktrunk::styling::{
    AnstyleStyle, ERROR, ERROR_EMOJI, HINT, HINT_EMOJI, WARNING, WARNING_EMOJI, eprintln, println,
};

use crate::commands::process::spawn_detached;
use crate::output::execute_command_in_worktree;

/// Result of a worktree switch operation
pub enum SwitchResult {
    /// Switched to existing worktree at the given path
    ExistingWorktree(PathBuf),
    /// Created new worktree at the given path
    CreatedWorktree { path: PathBuf, created_branch: bool },
}

impl SwitchResult {
    /// Get the worktree path
    pub fn path(&self) -> &PathBuf {
        match self {
            SwitchResult::ExistingWorktree(path) => path,
            SwitchResult::CreatedWorktree { path, .. } => path,
        }
    }
}

/// Result of a worktree remove operation
pub enum RemoveResult {
    /// Already on default branch, no action taken
    AlreadyOnDefault(String),
    /// Removed worktree and returned to primary
    RemovedWorktree { primary_path: PathBuf },
    /// Switched to default branch in main repo
    SwitchedToDefault(String),
}

pub fn handle_switch(
    branch: &str,
    create: bool,
    base: Option<&str>,
    force: bool,
    config: &WorktrunkConfig,
) -> Result<SwitchResult, GitError> {
    let repo = Repository::current();

    // Check for conflicting conditions
    if create && repo.branch_exists(branch)? {
        let error_bold = ERROR.bold();
        eprintln!(
            "{ERROR_EMOJI} {ERROR}Branch {error_bold}{branch}{error_bold:#} already exists{ERROR:#}"
        );
        eprintln!();
        eprintln!("{HINT_EMOJI} {HINT}Remove --create flag to switch to it{HINT:#}");
        return Err(GitError::CommandFailed(String::new()));
    }

    // Check if base flag was provided without create flag
    if base.is_some() && !create {
        eprintln!(
            "{WARNING_EMOJI} {WARNING}--base flag is only used with --create, ignoring{WARNING:#}"
        );
    }

    // Check if worktree already exists for this branch
    match repo.worktree_for_branch(branch)? {
        Some(existing_path) if existing_path.exists() => {
            // Canonicalize the path for cleaner display
            let canonical_existing_path = existing_path.canonicalize().unwrap_or(existing_path);
            return Ok(SwitchResult::ExistingWorktree(canonical_existing_path));
        }
        Some(_) => {
            let error_bold = ERROR.bold();
            eprintln!(
                "{ERROR_EMOJI} {ERROR}Worktree directory missing for {error_bold}{branch}{error_bold:#}{ERROR:#}"
            );
            eprintln!();
            eprintln!("{HINT_EMOJI} {HINT}Run 'git worktree prune' to clean up{HINT:#}");
            return Err(GitError::CommandFailed(String::new()));
        }
        None => {}
    }

    // No existing worktree, create one
    let repo_root = repo.repo_root()?;

    let repo_name = repo_root
        .file_name()
        .ok_or_else(|| GitError::CommandFailed("Invalid repository path".to_string()))?
        .to_str()
        .ok_or_else(|| GitError::CommandFailed("Invalid UTF-8 in path".to_string()))?;

    let worktree_path = repo_root.join(config.format_path(repo_name, branch));

    // Create the worktree
    // Build git worktree add command
    let mut args = vec!["worktree", "add", worktree_path.to_str().unwrap()];
    if create {
        args.push("-b");
        args.push(branch);
        if let Some(base_branch) = base {
            args.push(base_branch);
        }
    } else {
        args.push(branch);
    }

    repo.run_command(&args)
        .map_err(|e| GitError::CommandFailed(format!("Failed to create worktree: {}", e)))?;

    // Canonicalize the path for cleaner display
    let canonical_path = worktree_path
        .canonicalize()
        .unwrap_or_else(|_| worktree_path.clone());

    // Execute post-create commands (sequential, blocking)
    execute_post_create_commands(&canonical_path, &repo, config, branch, repo_name, force)?;

    // Spawn post-start commands (parallel, background)
    spawn_post_start_commands(&canonical_path, &repo, config, branch, repo_name, force)?;

    Ok(SwitchResult::CreatedWorktree {
        path: canonical_path,
        created_branch: create,
    })
}

pub fn handle_remove() -> Result<RemoveResult, GitError> {
    let repo = Repository::current();

    // Check for uncommitted changes
    repo.ensure_clean_working_tree()?;

    // Get current state
    let current_branch = repo.current_branch()?;
    let default_branch = repo.default_branch()?;
    let in_worktree = repo.is_in_worktree()?;

    // If we're on default branch and not in a worktree, nothing to do
    if !in_worktree && current_branch.as_deref() == Some(&default_branch) {
        return Ok(RemoveResult::AlreadyOnDefault(default_branch));
    }

    if in_worktree {
        // In worktree: navigate to primary worktree and remove this one
        let worktree_root = repo.worktree_root()?;
        let primary_worktree_dir = repo.repo_root()?;

        // Remove the worktree
        if let Err(e) = repo.remove_worktree(&worktree_root) {
            eprintln!("{WARNING_EMOJI} {WARNING}Failed to remove worktree: {e}{WARNING:#}");
            eprintln!(
                "You may need to run 'git worktree remove {}' manually",
                worktree_root.display()
            );
        }

        // Canonicalize the path for cleaner display
        let canonical_primary_path = primary_worktree_dir
            .canonicalize()
            .unwrap_or(primary_worktree_dir);

        Ok(RemoveResult::RemovedWorktree {
            primary_path: canonical_primary_path,
        })
    } else {
        // In main repo but not on default branch: switch to default
        repo.run_command(&["switch", &default_branch])
            .map_err(|e| {
                GitError::CommandFailed(format!("Failed to switch to '{}': {}", default_branch, e))
            })?;

        Ok(RemoveResult::SwitchedToDefault(default_branch))
    }
}

/// Check for conflicting uncommitted changes in target worktree
fn check_worktree_conflicts(
    repo: &Repository,
    target_worktree: &Option<std::path::PathBuf>,
    target_branch: &str,
) -> Result<(), GitError> {
    let Some(wt_path) = target_worktree else {
        return Ok(());
    };

    let wt_repo = Repository::at(wt_path);
    if !wt_repo.is_dirty()? {
        return Ok(());
    }

    // Get files changed in the push
    let push_files = repo.changed_files(target_branch, "HEAD")?;

    // Get files changed in the worktree
    let wt_status_output = wt_repo.run_command(&["status", "--porcelain"])?;

    let wt_files: Vec<String> = wt_status_output
        .lines()
        .filter_map(|line| {
            // Parse porcelain format: "XY filename"
            line.split_once(' ')
                .map(|(_, filename)| filename.trim().to_string())
        })
        .collect();

    // Find overlapping files
    let overlapping: Vec<String> = push_files
        .iter()
        .filter(|f| wt_files.contains(f))
        .cloned()
        .collect();

    if !overlapping.is_empty() {
        eprintln!("{ERROR_EMOJI} {ERROR}Cannot push: conflicting uncommitted changes in:{ERROR:#}");
        eprintln!();
        let dim = AnstyleStyle::new().dimmed();
        for file in &overlapping {
            eprintln!("  {dim}‚Ä¢{dim:#} {}", file);
        }
        eprintln!();
        eprintln!(
            "{HINT_EMOJI} {HINT}Commit or stash these changes in {} first{HINT:#}",
            wt_path.display()
        );
        return Err(GitError::CommandFailed(String::new()));
    }

    Ok(())
}

/// Replace template variables in a command string
///
/// Supported variables:
/// - `{repo}` - Repository name
/// - `{branch}` - Branch name (sanitized)
/// - `{worktree}` - Path to the new worktree
/// - `{repo_root}` - Path to the main repository root
fn expand_command_template(
    command: &str,
    repo_name: &str,
    branch: &str,
    worktree_path: &std::path::Path,
    repo_root: &std::path::Path,
) -> String {
    let mut extra = HashMap::new();
    extra.insert("worktree", worktree_path.to_str().unwrap_or(""));
    extra.insert("repo_root", repo_root.to_str().unwrap_or(""));

    expand_template(command, repo_name, branch, &extra)
}

/// Prompt the user to approve a command for execution
fn prompt_for_approval(command: &str, project_id: &str) -> io::Result<bool> {
    use anstyle::Style;
    use worktrunk::styling::{HINT_EMOJI, eprint};

    // Extract project name from project_id (e.g., "worktrunk" from "github.com/max-sixty/worktrunk")
    let project_name = project_id.split('/').next_back().unwrap_or(project_id);
    let bold = Style::new().bold();
    let dim = Style::new().dimmed();

    eprintln!();
    eprintln!("{WARNING_EMOJI} {WARNING}Permission required to execute in worktree{WARNING:#}");
    eprintln!();
    eprintln!("{bold}{project_name}{bold:#} ({project_id}) wants to execute:");
    eprintln!();
    eprintln!("    {dim}{command}{dim:#}");
    eprintln!();
    eprint!("{HINT_EMOJI} Allow and remember? {bold}[y/N]{bold:#} ");
    io::stderr().flush()?;

    let mut input = String::new();
    io::stdin().read_line(&mut input)?;

    let response = input.trim().to_lowercase();
    Ok(response == "y" || response == "yes")
}

/// Helper to load project config with error handling
fn load_project_config(repo: &Repository) -> Result<Option<ProjectConfig>, GitError> {
    let repo_root = repo.repo_root()?;
    let config_path = repo_root.join(".config").join("wt.toml");
    match ProjectConfig::load(&repo_root) {
        Ok(cfg) => Ok(cfg),
        Err(e) => {
            eprintln!(
                "{WARNING_EMOJI} {WARNING}Failed to load project config from {}{WARNING:#}",
                config_path.display()
            );
            eprintln!("{HINT_EMOJI} {HINT}Error details: {e}{HINT:#}");
            eprintln!(
                "{HINT_EMOJI} {HINT}Skipping commands. Check TOML syntax if file exists.{HINT:#}"
            );
            Ok(None)
        }
    }
}

/// Convert CommandConfig to a vector of (name, command) pairs
fn command_config_to_vec(config: &worktrunk::config::CommandConfig) -> Vec<(String, String)> {
    use worktrunk::config::CommandConfig;
    match config {
        CommandConfig::Single(cmd) => vec![("default".to_string(), cmd.clone())],
        CommandConfig::Multiple(cmds) => cmds
            .iter()
            .enumerate()
            .map(|(i, cmd)| (format!("cmd-{}", i), cmd.clone()))
            .collect(),
        CommandConfig::Named(map) => {
            let mut pairs: Vec<_> = map.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
            // Sort by name for deterministic iteration order
            pairs.sort_by(|a, b| a.0.cmp(&b.0));
            pairs
        }
    }
}

/// Execute post-create commands sequentially (blocking)
fn execute_post_create_commands(
    worktree_path: &std::path::Path,
    repo: &Repository,
    config: &WorktrunkConfig,
    branch: &str,
    repo_name: &str,
    force: bool,
) -> Result<(), GitError> {
    let project_config = match load_project_config(repo)? {
        Some(cfg) => cfg,
        None => return Ok(()),
    };

    let Some(post_create_config) = &project_config.post_create_command else {
        return Ok(());
    };

    let commands = command_config_to_vec(post_create_config);
    if commands.is_empty() {
        return Ok(());
    }

    let project_id = repo.project_identifier()?;
    let repo_root = repo.repo_root()?;

    // Execute each command sequentially
    for (name, command) in commands {
        if !check_and_approve_command(&project_id, &command, config, force)? {
            let dim = AnstyleStyle::new().dimmed();
            eprintln!("{dim}Skipping command: {command}{dim:#}");
            continue;
        }

        let expanded_command =
            expand_command_template(&command, repo_name, branch, worktree_path, &repo_root);

        use anstyle::{AnsiColor, Color};
        use std::io::Write;
        let cyan = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Cyan)));
        eprintln!("üîÑ {cyan}Executing (post-create): {expanded_command}{cyan:#}");
        let _ = std::io::stderr().flush();

        if let Err(e) = execute_command_in_worktree(worktree_path, &expanded_command) {
            eprintln!("{WARNING_EMOJI} {WARNING}Command '{name}' failed: {e}{WARNING:#}");
            // Continue with other commands even if one fails
        }
    }

    use std::io::Write;
    let _ = std::io::stdout().flush();
    let _ = std::io::stderr().flush();

    Ok(())
}

/// Spawn post-start commands in parallel as background processes (non-blocking)
fn spawn_post_start_commands(
    worktree_path: &std::path::Path,
    repo: &Repository,
    config: &WorktrunkConfig,
    branch: &str,
    repo_name: &str,
    force: bool,
) -> Result<(), GitError> {
    let project_config = match load_project_config(repo)? {
        Some(cfg) => cfg,
        None => return Ok(()),
    };

    let Some(post_start_config) = &project_config.post_start_command else {
        return Ok(());
    };

    let commands = command_config_to_vec(post_start_config);
    if commands.is_empty() {
        return Ok(());
    }

    let project_id = repo.project_identifier()?;
    let repo_root = repo.repo_root()?;

    // Spawn each command as a detached background process
    for (name, command) in commands {
        if !check_and_approve_command(&project_id, &command, config, force)? {
            let dim = AnstyleStyle::new().dimmed();
            eprintln!("{dim}Skipping command: {command}{dim:#}");
            continue;
        }

        let expanded_command =
            expand_command_template(&command, repo_name, branch, worktree_path, &repo_root);

        use anstyle::{AnsiColor, Color};
        use std::io::Write;
        let cyan = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Cyan)));
        eprintln!("üîÑ {cyan}Starting (background): {expanded_command}{cyan:#}");
        let _ = std::io::stderr().flush();

        match spawn_detached(worktree_path, &expanded_command, &name) {
            Ok(log_path) => {
                let dim = AnstyleStyle::new().dimmed();
                // Show relative path from worktree/.git/wt-logs/
                let display_path = if let Some(filename) = log_path.file_name() {
                    format!(".git/wt-logs/{}", filename.to_string_lossy())
                } else {
                    log_path.display().to_string()
                };
                eprintln!("  {dim}‚Üí Logs: {}{dim:#}", display_path);
            }
            Err(e) => {
                eprintln!("{WARNING_EMOJI} {WARNING}Failed to spawn '{name}': {e}{WARNING:#}");
            }
        }
    }

    use std::io::Write;
    let _ = std::io::stdout().flush();
    let _ = std::io::stderr().flush();

    Ok(())
}

/// Check if command is approved and prompt if needed
fn check_and_approve_command(
    project_id: &str,
    command: &str,
    config: &WorktrunkConfig,
    force: bool,
) -> Result<bool, GitError> {
    if force || config.is_command_approved(project_id, command) {
        return Ok(true);
    }

    match prompt_for_approval(command, project_id) {
        Ok(true) => {
            // Reload config and save approval
            match WorktrunkConfig::load() {
                Ok(mut fresh_config) => {
                    if let Err(e) =
                        fresh_config.approve_command(project_id.to_string(), command.to_string())
                    {
                        eprintln!(
                            "{WARNING_EMOJI} {WARNING}Failed to save command approval: {e}{WARNING:#}"
                        );
                        eprintln!("You will be prompted again next time.");
                    }
                }
                Err(e) => {
                    eprintln!(
                        "{WARNING_EMOJI} {WARNING}Failed to reload config for saving approval: {e}{WARNING:#}"
                    );
                    eprintln!("You will be prompted again next time.");
                }
            }
            Ok(true)
        }
        Ok(false) => Ok(false),
        Err(e) => {
            eprintln!("{WARNING_EMOJI} {WARNING}Failed to read user input: {e}{WARNING:#}");
            Ok(false)
        }
    }
}

pub fn handle_push(target: Option<&str>, allow_merge_commits: bool) -> Result<(), GitError> {
    use anstyle::{AnsiColor, Color};

    let repo = Repository::current();

    // Get target branch (default to default branch if not provided)
    let target_branch = target.map_or_else(|| repo.default_branch(), |b| Ok(b.to_string()))?;

    // Check if it's a fast-forward
    if !repo.is_ancestor(&target_branch, "HEAD")? {
        let error_bold = ERROR.bold();
        eprintln!(
            "{ERROR_EMOJI} {ERROR}Not a fast-forward from {error_bold}{target_branch}{error_bold:#} to HEAD{ERROR:#}"
        );
        eprintln!();
        eprintln!(
            "{HINT_EMOJI} {HINT}The target branch has commits not in your current branch{HINT:#}"
        );
        eprintln!("{HINT_EMOJI} {HINT}Consider: git pull or git rebase{HINT:#}");
        return Err(GitError::CommandFailed(String::new()));
    }

    // Check for merge commits unless allowed
    if !allow_merge_commits && repo.has_merge_commits(&target_branch, "HEAD")? {
        eprintln!("{ERROR_EMOJI} {ERROR}Found merge commits in push range{ERROR:#}");
        eprintln!();
        eprintln!(
            "{HINT_EMOJI} {HINT}Use --allow-merge-commits to push non-linear history{HINT:#}"
        );
        return Err(GitError::CommandFailed(String::new()));
    }

    // Configure receive.denyCurrentBranch if needed
    let current_config = repo.get_config("receive.denyCurrentBranch")?;
    if current_config.as_deref() != Some("updateInstead") {
        repo.set_config("receive.denyCurrentBranch", "updateInstead")?;
    }

    // Check for conflicting changes in target worktree
    let target_worktree = repo.worktree_for_branch(&target_branch)?;
    check_worktree_conflicts(&repo, &target_worktree, &target_branch)?;

    // Count commits and show what will be pushed
    let commit_count = repo.count_commits(&target_branch, "HEAD")?;

    // Get diff statistics early so we can use them in the summary
    let diff_shortstat = if commit_count > 0 {
        repo.run_command(&["diff", "--shortstat", &format!("{}..HEAD", target_branch)])?
    } else {
        String::new()
    };

    if commit_count > 0 {
        let commit_text = if commit_count == 1 {
            "commit"
        } else {
            "commits"
        };
        let head_sha = repo.run_command(&["rev-parse", "--short", "HEAD"])?;
        let head_sha = head_sha.trim();

        let cyan = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Cyan)));
        let cyan_bold = cyan.bold();

        println!(
            "üîÑ {cyan}Pushing {commit_count} {commit_text} to {cyan_bold}{target_branch}{cyan_bold:#} @ {head_sha}{cyan:#}"
        );
        println!();

        // Show the commit graph with color
        let log_output = repo.run_command(&[
            "log",
            "--color=always",
            "--graph",
            "--oneline",
            "--decorate",
            &format!("{}..HEAD", target_branch),
        ])?;
        println!("{}", log_output.trim());
        println!();

        // Show diff statistics with color
        let diff_stat = repo.run_command(&[
            "diff",
            "--color=always",
            "--stat",
            &format!("{}..HEAD", target_branch),
        ])?;

        let diff_stat = diff_stat.trim_end();
        if !diff_stat.is_empty() {
            println!("{}", diff_stat);
            println!();
        }
    }

    // Get git common dir for the push
    let git_common_dir = repo.git_common_dir()?;

    // Perform the push
    let push_target = format!("HEAD:{}", target_branch);
    repo.run_command(&["push", git_common_dir.to_str().unwrap(), &push_target])
        .map_err(|e| {
            GitError::CommandFailed(format!("{ERROR_EMOJI} {ERROR}Push failed: {e}{ERROR:#}"))
        })?;

    // Build success message with statistics
    let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
    let green_bold = green.bold();

    if commit_count > 0 {
        // Parse shortstat to extract files/insertions/deletions
        // Example: " 3 files changed, 45 insertions(+), 12 deletions(-)"
        let stats = parse_diff_shortstat(&diff_shortstat);

        let mut summary_parts = vec![format!(
            "{} commit{}",
            commit_count,
            if commit_count == 1 { "" } else { "s" }
        )];

        if let Some(files) = stats.files {
            summary_parts.push(format!(
                "{} file{}",
                files,
                if files == 1 { "" } else { "s" }
            ));
        }
        if let Some(insertions) = stats.insertions {
            let addition = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
            summary_parts.push(format!("{addition}+{insertions}{addition:#}"));
        }
        if let Some(deletions) = stats.deletions {
            let deletion = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Red)));
            summary_parts.push(format!("{deletion}-{deletions}{deletion:#}"));
        }

        println!(
            "‚úÖ {green}Pushed to {green_bold}{target_branch}{green_bold:#} ({})  {green:#}",
            summary_parts.join(", ")
        );
    } else {
        println!("‚úÖ {green}Pushed to {green_bold}{target_branch}{green_bold:#}{green:#}");
    }

    Ok(())
}

/// Parse git diff --shortstat output
struct DiffStats {
    files: Option<usize>,
    insertions: Option<usize>,
    deletions: Option<usize>,
}

fn parse_diff_shortstat(output: &str) -> DiffStats {
    let mut stats = DiffStats {
        files: None,
        insertions: None,
        deletions: None,
    };

    // Example: " 3 files changed, 45 insertions(+), 12 deletions(-)"
    let parts: Vec<&str> = output.split(',').collect();

    for part in parts {
        let part = part.trim();

        if part.contains("file") {
            if let Some(num_str) = part.split_whitespace().next() {
                stats.files = num_str.parse().ok();
            }
        } else if part.contains("insertion") {
            if let Some(num_str) = part.split_whitespace().next() {
                stats.insertions = num_str.parse().ok();
            }
        } else if part.contains("deletion")
            && let Some(num_str) = part.split_whitespace().next()
        {
            stats.deletions = num_str.parse().ok();
        }
    }

    stats
}
